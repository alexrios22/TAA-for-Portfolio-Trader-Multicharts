////////////////////////////////////////////////
// PMM SIGNAL: BAA_Portfolio_MM
// Portfolio Money Management para BAA
// Implementa logica de score compuesto y proteccion
////////////////////////////////////////////////

Inputs:
    NumTopPositions(6),         // Top N activos a mantener
    MinCanaryBad(1),            // # de canarios malos para activar proteccion
    RebalanceFrequency(0),      // 0=Monthly, 1=Quarterly, 2=Annually
    VerboseMode(False);

Vars:
    portfolioStrategies(0),
    idx(0),
    jdx(0),
    
    // Contadores por universo
    totalCanary(0),
    totalOffensive(0),
    totalDefensive(0),
    negMomentumCanaries(0),
    
    // Variables para calculo
    momentum(0),
    volatility(0),
    invVolatility(0),
    assetUniverse(0),
    strategyIdx(0),
    
    // Proteccion
    useDefensiveOnly(False),
    
    // Pesos
    weightPerAsset(0),
    
    // Rebalanceo
    isRebalanceDay(False),
    currentMonth(0),
    
    // Ranking
    momentumRank(0),
    invVolRank(0),
    compositeScore(0),
    
    // Tracking
    assetsAllocated(0);

// Arrays para datos y ranking
array: 
    canaryMomentum[2, 1000](0),
    offensiveMom[1000](0),
    offensiveVol[1000](0),
    offensiveInvVol[1000](0),
    offensiveIdx[1000](0),
    defensiveMom[1000](0),
    defensiveVol[1000](0),
    defensiveInvVol[1000](0),
    defensiveIdx[1000](0),
    
    // Rankings
    momentumRanks[1000](0),
    invVolRanks[1000](0),
    compositeScores[2, 1000](0);

// Restricciones
once if 1 <> getappinfo(aiisportfoliomode) then
    raiseruntimeerror("BAA Portfolio MM can be applied for MCPortfolio application only.");

once if pmms_strategies_count() > 1000 then
    raiseruntimeerror("BAA Portfolio MM: too many instruments, max = 1000");

once begin
    portfolioStrategies = pmms_strategies_count();
end;

// ================================================
// DETECTAR DiA DE REBALANCEO
// ================================================

currentMonth = Month(date);
isRebalanceDay = False;

If RebalanceFrequency = 0 then begin
    // Mensual: Ultima barra del mes
    If LastTradingDayOfMonth then
        isRebalanceDay = True;
end
else If RebalanceFrequency = 1 then begin
    // Trimestral
    If LastTradingDayOfMonth AND (currentMonth = 3 OR currentMonth = 6 OR currentMonth = 9 OR currentMonth = 12) then
        isRebalanceDay = True;
end
else If RebalanceFrequency = 2 then begin
    // Anual
    If LastTradingDayOfMonth AND currentMonth = 12 then
        isRebalanceDay = True;
end;

pmms_strategies_deny_entries_all();

// ================================================
// PROCESAMIENTO EN DiA DE REBALANCEO
// ================================================

If isRebalanceDay then begin
    
    // ================================================
    // PASO 1: RECOPILAR Y SEPARAR DATOS
    // ================================================
    
    totalCanary = 0;
    totalOffensive = 0;
    totalDefensive = 0;
    negMomentumCanaries = 0;
    
    For idx = 0 to portfolioStrategies - 1 begin
        momentum = pmms_get_strategy_named_num(idx, "Momentum");
        volatility = pmms_get_strategy_named_num(idx, "Volatility");
        assetUniverse = pmms_get_strategy_named_num(idx, "AssetUniverse");
        
        // Calcular volatilidad inversa
        If volatility > 0 then
            invVolatility = 1 / volatility
        else
            invVolatility = 0;
        
        // Separar por universo
        If assetUniverse = 0 then begin
            // Canary
            totalCanary = totalCanary + 1;
            canaryMomentum[1, totalCanary] = momentum;
            canaryMomentum[2, totalCanary] = idx;
            
            If momentum <= 0 then
                negMomentumCanaries = negMomentumCanaries + 1;
        end
        else If assetUniverse = 1 then begin
            // Offensive
            totalOffensive = totalOffensive + 1;
            offensiveMom[totalOffensive] = momentum;
            offensiveVol[totalOffensive] = volatility;
            offensiveInvVol[totalOffensive] = invVolatility;
            offensiveIdx[totalOffensive] = idx;
        end
        else If assetUniverse = 2 then begin
            // Defensive
            totalDefensive = totalDefensive + 1;
            defensiveMom[totalDefensive] = momentum;
            defensiveVol[totalDefensive] = volatility;
            defensiveInvVol[totalDefensive] = invVolatility;
            defensiveIdx[totalDefensive] = idx;
        end;
    end;
    
    // ================================================
    // PASO 2: DETERMINAR PROTECCIoN
    // ================================================
    
    useDefensiveOnly = (negMomentumCanaries >= MinCanaryBad);
    
    If VerboseMode then begin
        print("========================================");
        print("BAA REBALANCE: ", Date:0:0);
        print("========================================");
        print("CANARY UNIVERSE:");
        print("  Total Canaries: ", totalCanary:0:0);
        print("  Neg Momentum: ", negMomentumCanaries:0:0);
        print("  Use Defensive Only: ", useDefensiveOnly);
        print("========================================");
    end;
    
    // ================================================
    // PASO 3: CALCULAR SCORES Y RANKING
    // ================================================
    
    Vars: workingTotal(0), workingPool(0);
    
    If useDefensiveOnly then begin
        workingTotal = totalDefensive;
        workingPool = 2; // Defensive
    end
    else begin
        workingTotal = totalOffensive;
        workingPool = 1; // Offensive
    end;
    
    If workingTotal = 0 then begin
        If VerboseMode then
            print("WARNING: No assets available in selected pool!");
    end
    else begin
        
        // Calcular rankings de momentum
        For idx = 1 to workingTotal begin
            momentumRanks[idx] = 0;
            
            For jdx = 1 to workingTotal begin
                If workingPool = 1 then begin
                    If offensiveMom[jdx] > offensiveMom[idx] then
                        momentumRanks[idx] = momentumRanks[idx] + 1;
                end
                else begin
                    If defensiveMom[jdx] > defensiveMom[idx] then
                        momentumRanks[idx] = momentumRanks[idx] + 1;
                end;
            end;
            
            momentumRanks[idx] = momentumRanks[idx] + 1; // Rank base-1
        end;
        
        // Calcular rankings de volatilidad inversa
        For idx = 1 to workingTotal begin
            invVolRanks[idx] = 0;
            
            For jdx = 1 to workingTotal begin
                If workingPool = 1 then begin
                    If offensiveInvVol[jdx] > offensiveInvVol[idx] then
                        invVolRanks[idx] = invVolRanks[idx] + 1;
                end
                else begin
                    If defensiveInvVol[jdx] > defensiveInvVol[idx] then
                        invVolRanks[idx] = invVolRanks[idx] + 1;
                end;
            end;
            
            invVolRanks[idx] = invVolRanks[idx] + 1; // Rank base-1
        end;
        
        // Calcular composite score (suma de ranks)
        For idx = 1 to workingTotal begin
            compositeScore = momentumRanks[idx] + invVolRanks[idx];
            compositeScores[1, idx] = compositeScore;
            
            If workingPool = 1 then
                compositeScores[2, idx] = offensiveIdx[idx]
            else
                compositeScores[2, idx] = defensiveIdx[idx];
        end;
        
        // Ordenar por composite score (menor score = mejor)
        Sort2DArray(compositeScores, 2, workingTotal, 1);
        
        // ================================================
        // PASO 4: IDENTIFICAR ASSETS EN TOP N
        // ================================================
        
        // Array para marcar cuales assets deben estar en TopN
        Array: shouldBeInTopN[1000](False);
        
        // IMPORTANTE: Reinicializar array a False
        For idx = 0 to portfolioStrategies - 1 begin
            shouldBeInTopN[idx] = False;
        end;
        
        Vars: maxToSelect(0);
        maxToSelect = MinList(NumTopPositions, workingTotal);
        
        // Marcar los TopN assets
        For idx = 1 to maxToSelect begin
            strategyIdx = compositeScores[2, idx];
            shouldBeInTopN[strategyIdx] = True;
        end;
        
        // ================================================
        // PASO 5: CERRAR POSICIONES QUE NO ESTaN EN TOP N
        // ================================================
        
        For idx = 0 to portfolioStrategies - 1 begin
            If pmms_strategy_marketposition(idx) <> 0 then begin
                If shouldBeInTopN[idx] = False then begin
                    pmms_strategy_close_position(idx);
                    
                    If VerboseMode then
                        print("Closing: ", pmms_strategy_symbol(idx));
                end;
            end;
        end;
        
        // ================================================
        // PASO 6: ASIGNAR PESOS Y ABRIR/MANTENER POSICIONES
        // ================================================
        
        If maxToSelect > 0 then
            weightPerAsset = 100 / maxToSelect
        else
            weightPerAsset = 0;
        
        assetsAllocated = 0;
        
        If VerboseMode then begin
            print("SELECTED POOL: ", IFF(workingPool = 1, "Offensive", "Defensive"));
            print("Total Assets: ", workingTotal:0:0);
            print("Max to Select: ", maxToSelect:0:0);
            print("Weight per Asset: ", weightPerAsset:0:2, "%");
            print("----------------------------------------");
        end;
        
        For idx = 1 to maxToSelect begin
            strategyIdx = compositeScores[2, idx];
            compositeScore = compositeScores[1, idx];
            
            If weightPerAsset > 0 then begin
                pmms_strategy_set_entry_contracts(strategyIdx, 
                    IntPortion(Portfolio_Equity * weightPerAsset / 100 / Close)
                );
                pmms_strategy_allow_long_entries(strategyIdx);
                
                assetsAllocated = assetsAllocated + 1;
                
                If VerboseMode then begin
                    momentum = pmms_get_strategy_named_num(strategyIdx, "Momentum");
                    volatility = pmms_get_strategy_named_num(strategyIdx, "Volatility");
                    
                    print("Asset ", idx:0:0, ": ", pmms_strategy_symbol(strategyIdx));
                    print("  Composite Score: ", compositeScore:0:2);
                    print("  Momentum: ", momentum:0:4, " | Vol: ", volatility:0:4);
                    print("  Weight: ", weightPerAsset:0:2, "%");
                end;
            end;
        end;
        
        If VerboseMode then begin
            print("----------------------------------------");
            print("Assets Allocated: ", assetsAllocated:0:0);
            print("Total Weight: ", (assetsAllocated * weightPerAsset):0:2, "%");
            print("========================================");
        end;
    end;
end;
